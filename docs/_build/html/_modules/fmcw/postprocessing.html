

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>fmcw.postprocessing &mdash; fmcw  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> fmcw
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../source/modules.html">fmcw</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">fmcw</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>fmcw.postprocessing</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for fmcw.postprocessing</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">ast</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="k">import</span> <span class="n">butter</span><span class="p">,</span> <span class="n">filtfilt</span>
<span class="kn">import</span> <span class="nn">io</span>
<span class="kn">from</span> <span class="nn">queue</span> <span class="k">import</span> <span class="n">Queue</span><span class="p">,</span> <span class="n">Empty</span>
<span class="kn">from</span> <span class="nn">threading</span> <span class="k">import</span> <span class="n">Thread</span>
<span class="kn">import</span> <span class="nn">csv</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">multiprocessing</span> <span class="k">as</span> <span class="nn">mp</span>
<span class="kn">from</span> <span class="nn">fmcw</span> <span class="k">import</span> <span class="n">ftdi</span><span class="p">,</span> <span class="n">adc</span>


<span class="kn">import</span> <span class="nn">matplotlib</span>
<span class="c1">#matplotlib.use(&#39;Qt5Agg&#39;)  # Use another backend</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">rc</span><span class="p">(</span><span class="s1">&#39;image&#39;</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;jet&#39;</span><span class="p">)</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ion</span><span class="p">()</span>


<div class="viewcode-block" id="butter_highpass"><a class="viewcode-back" href="../../source/fmcw.html#fmcw.postprocessing.butter_highpass">[docs]</a><span class="k">def</span> <span class="nf">butter_highpass</span><span class="p">(</span><span class="n">cutoff</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    User friendly wrapper for a highpass scipy.signal.butter</span>
<span class="sd">    :param cutoff: cutoff frequency</span>
<span class="sd">    :param fs: sampling frequency</span>
<span class="sd">    :param order: order of the Butterworth filter</span>
<span class="sd">    :return: scipy butter objects</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nyq</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">fs</span>
    <span class="n">normal_cutoff</span> <span class="o">=</span> <span class="n">cutoff</span> <span class="o">/</span> <span class="n">nyq</span>
    <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">butter</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="n">normal_cutoff</span><span class="p">,</span> <span class="n">btype</span><span class="o">=</span><span class="s1">&#39;high&#39;</span><span class="p">,</span> <span class="n">analog</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span></div>


<div class="viewcode-block" id="butter_highpass_filter"><a class="viewcode-back" href="../../source/fmcw.html#fmcw.postprocessing.butter_highpass_filter">[docs]</a><span class="k">def</span> <span class="nf">butter_highpass_filter</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Filter data with a highpass scipy.signal.butter</span>
<span class="sd">    :param data: Data to filter</span>
<span class="sd">    :param cutoff: Cutoff frequency</span>
<span class="sd">    :param fs: Sampling frequency</span>
<span class="sd">    :param order: Order of the Butterworth filter</span>
<span class="sd">    :return: Filtered data</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">butter_highpass</span><span class="p">(</span><span class="n">cutoff</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">filtfilt</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">y</span></div>


<div class="viewcode-block" id="twos_comp"><a class="viewcode-back" href="../../source/fmcw.html#fmcw.postprocessing.twos_comp">[docs]</a><span class="k">def</span> <span class="nf">twos_comp</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">bits</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the 2&#39;s complement of int value val</span>
<span class="sd">    :param val: Bytes to complement</span>
<span class="sd">    :param bits:</span>
<span class="sd">    :return: 2&#39;s complement of int value val</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">bits</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># if sign bit is set e.g., 8bit: 128-255</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">val</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">bits</span><span class="p">)</span>        <span class="c1"># compute negative value</span>
    <span class="k">return</span> <span class="n">val</span>                         <span class="c1"># return positive value as is</span></div>


<div class="viewcode-block" id="f_to_d"><a class="viewcode-back" href="../../source/fmcw.html#fmcw.postprocessing.f_to_d">[docs]</a><span class="k">def</span> <span class="nf">f_to_d</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts frequency bins to distance bins based on ADC settings</span>
<span class="sd">    :param f: Frequency bins</span>
<span class="sd">    :param s: Settings dictionary</span>
<span class="sd">    :return: Distance bins</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;c&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">f</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;bw&#39;</span><span class="p">]</span><span class="o">/</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;t_sweep&#39;</span><span class="p">]))</span></div>

<div class="viewcode-block" id="create_bases"><a class="viewcode-back" href="../../source/fmcw.html#fmcw.postprocessing.create_bases">[docs]</a><span class="k">def</span> <span class="nf">create_bases</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create the x axis data for all sorts of plots. This will speed up the display of the plots by caching it and</span>
<span class="sd">    limiting the amount of data to be redrawn.</span>
<span class="sd">    :param s: Settings dictionary</span>
<span class="sd">    :return: time, frequency, distance, angle bins</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">wl</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;c&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;f0&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;bw&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># [m] Center wavelength</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;t_sweep&#39;</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;sweep_length&#39;</span><span class="p">])</span>  <span class="c1"># [s] Time base</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;if_amplifier_bandwidth&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;sweep_length&#39;</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># [Hz] Frequency base</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">f_to_d</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>  <span class="c1"># [m] Distance base</span>

    <span class="n">angles</span> <span class="o">=</span> <span class="mi">180</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;angle_pad&#39;</span><span class="p">])</span> <span class="o">*</span> <span class="n">wl</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;d_antenna&#39;</span><span class="p">]))</span>  <span class="c1"># [Â°] Degree base</span>
    <span class="k">return</span> <span class="n">t</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">angles</span></div>

<div class="viewcode-block" id="r4_normalize"><a class="viewcode-back" href="../../source/fmcw.html#fmcw.postprocessing.r4_normalize">[docs]</a><span class="k">def</span> <span class="nf">r4_normalize</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span><span class="o">=</span><span class="mf">1.5</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Not sure what this does. Used when processing the angle data</span>
<span class="sd">    :param x:</span>
<span class="sd">    :param d:</span>
<span class="sd">    :param e:</span>
<span class="sd">    :return:</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="n">e</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">*</span><span class="n">d</span><span class="o">**</span><span class="n">e</span><span class="o">/</span><span class="n">n</span></div>


<div class="viewcode-block" id="read_settings"><a class="viewcode-back" href="../../source/fmcw.html#fmcw.postprocessing.read_settings">[docs]</a><span class="k">def</span> <span class="nf">read_settings</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reads the first line of a file and evaluates it as python code. Used when reading the binary log as the first line</span>
<span class="sd">    contains the settings dictionary.</span>
<span class="sd">    :param f: File handle</span>
<span class="sd">    :param encoding:</span>
<span class="sd">    :return: Settings dictionary from string evaluated as python code</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">f</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="n">encoding</span><span class="p">)</span> <span class="k">if</span> <span class="n">encoding</span> <span class="k">else</span> <span class="n">data</span>
    <span class="n">settings</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">literal_eval</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">settings</span></div>

<div class="viewcode-block" id="find_start_batch"><a class="viewcode-back" href="../../source/fmcw.html#fmcw.postprocessing.find_start_batch">[docs]</a><span class="k">def</span> <span class="nf">find_start_batch</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">initial_index</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the starting index of the first valid batch of sweep data and its corresponding header.</span>
<span class="sd">    :param data: Batch of data coming from the FPGA via the USB port</span>
<span class="sd">    :param s: Settings dictionary</span>
<span class="sd">    :param initial_index: 0 if reading a new batch, non zero if finding the next valid sweep within a batch</span>
<span class="sd">    :return: Starting index of a sweep data, header of that sweep</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">flag_valid_header</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">initial_index</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">-</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;nbytes_sweep&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="p">):</span>
        <span class="n">current_header</span> <span class="o">=</span> <span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span>
        <span class="k">if</span> <span class="n">current_header</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;start&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">data</span><span class="p">[</span><span class="n">index</span> <span class="o">+</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;nbytes_sweep&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">s</span><span class="p">[</span>
            <span class="s1">&#39;start&#39;</span><span class="p">]:</span>  <span class="c1"># Not 100% foolproof, but cannot be anyway</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;[INFO] Found start signal </span><span class="si">{}</span><span class="s2"> at position </span><span class="si">{}</span><span class="s2"> (jumped </span><span class="si">{}</span><span class="s2"> byte).&quot;</span>
                  <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">current_header</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">index</span><span class="o">-</span><span class="n">initial_index</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;[INFO] Next header would read [</span><span class="si">{}</span><span class="s2">, </span><span class="si">{}</span><span class="s2">]&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">index</span> <span class="o">+</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;nbytes_sweep&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="p">],</span>
                                                                  <span class="n">data</span><span class="p">[</span><span class="n">index</span> <span class="o">+</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;nbytes_sweep&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="mi">3</span><span class="p">]))</span>
            <span class="n">flag_valid_header</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">break</span>
    <span class="k">if</span> <span class="n">flag_valid_header</span><span class="p">:</span>  <span class="c1"># All good</span>
        <span class="n">index</span> <span class="o">+=</span> <span class="mi">2</span>  <span class="c1"># Skip the header, it is saved in current_header</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># index = -1  # No valid header was found</span>
        <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">current_header</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="c1">#print(&quot;[ERROR] index: {} | len(data): {} | s[&#39;nbytes_sweep&#39;]: {}&quot;.format(index, len(data), s[&#39;nbytes_sweep&#39;]))</span>
        <span class="c1">#raise ValueError(&#39;[ERROR] No valid header found in the data!&#39;)</span>

    <span class="k">assert</span> <span class="n">index</span> <span class="o">&gt;=</span> <span class="mi">0</span>
    <span class="k">assert</span> <span class="n">current_header</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">127</span> <span class="ow">or</span> <span class="n">current_header</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">index</span><span class="p">,</span> <span class="n">current_header</span></div>

<div class="viewcode-block" id="process_batch"><a class="viewcode-back" href="../../source/fmcw.html#fmcw.postprocessing.process_batch">[docs]</a><span class="k">def</span> <span class="nf">process_batch</span><span class="p">(</span><span class="n">rest</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">next_header</span><span class="p">,</span> <span class="n">counter_decimation</span><span class="p">,</span> <span class="n">sweep_count</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Main function to process incoming batches of data from the FPGA. The goal is to find valid sweeps in the data. Main </span>
<span class="sd">    challenges are that the start of the data might come from the end of a previous sweep, there might be some dropped </span>
<span class="sd">    byte in some sweeps due to latency from the OS vs real time FPGA, and a last sweep that is incomplete and has to be </span>
<span class="sd">    merged with the next batch.</span>
<span class="sd">    :param rest: End of the previous batch that was not long enough to constitute a whole sweep.</span>
<span class="sd">    :param data: New batch of USB data from the FPGA</span>
<span class="sd">    :param s: Settings dictionary</span>
<span class="sd">    :param next_header: Expected header of the next sweep</span>
<span class="sd">    :param counter_decimation: Rolling counter, keeps track of software decimation across batches</span>
<span class="sd">    :param sweep_count: Global number of valid, post decimation sweeps that have been found</span>
<span class="sd">    :param verbose: A lot of extra info will be displayed</span>
<span class="sd">    :return: batch_ch, next_header, rest, sweep_count, counter_decimation</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Sanity checks on types</span>
    <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">rest</span><span class="p">)</span><span class="o">==</span><span class="nb">bytes</span> <span class="ow">or</span> <span class="n">rest</span> <span class="o">==</span> <span class="kc">None</span>
    <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">==</span><span class="nb">bytes</span>
    <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;start&#39;</span><span class="p">])</span><span class="o">==</span><span class="nb">int</span>
    <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;nbytes_sweep&#39;</span><span class="p">])</span><span class="o">==</span><span class="nb">int</span>
    <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">next_header</span><span class="p">)</span><span class="o">==</span><span class="nb">list</span>

    <span class="c1"># Sanity checks on length</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">next_header</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
    <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">next_header</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">next_header</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">rest</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>

    <span class="c1"># Sanity check on nature of next_header</span>
    <span class="k">assert</span> <span class="n">next_header</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;start&#39;</span><span class="p">]]</span>  <span class="c1"># Can be the start signal or an error code</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rest</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">rest</span><span class="p">))</span>
    <span class="c1"># 0. Create temp variables</span>
    <span class="c1">#counter_decimation = 0  # For software decimation</span>
    <span class="n">sweeps_scanned</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">skipped_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;nbytes_sweep&#39;</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span>  <span class="c1"># Create the 0 array only once</span>
    <span class="n">batch_ch</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;channel_count&#39;</span><span class="p">]):</span>
        <span class="n">batch_ch</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># data_2[k + 1] = []</span>
    <span class="n">batch_ch</span><span class="p">[</span><span class="s1">&#39;skipped_sweeps&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Stores the skipped frames for both channels</span>

    <span class="c1"># 1. Concatenate the rest with the data</span>
    <span class="n">initial_data_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>  <span class="c1"># DEBUG</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">rest</span> <span class="o">+</span> <span class="n">data</span>  <span class="c1"># Concatenate the bytearrays</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;patience_data_length&#39;</span><span class="p">]:</span>  <span class="c1"># Threshold in data length</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;[ERROR] No valid header found in these </span><span class="si">{}</span><span class="s1"> byte of data&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)))</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;[INFO] rest length: </span><span class="si">{}</span><span class="s2"> | block: </span><span class="si">{}</span><span class="s2"> long | shape to process: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rest</span><span class="p">),</span> <span class="n">initial_data_length</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)))</span>
    <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="nb">bytes</span>

    <span class="c1"># 2. Find the start</span>
    <span class="k">if</span> <span class="n">next_header</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;start&#39;</span><span class="p">]:</span>  <span class="c1"># The start was not found</span>
        <span class="c1"># This can happen if the previous sweep ended with a lot of data but no valid header.</span>
        <span class="c1"># All the remaining data was carried over as rest. Once a new valid header is found, we can see how many</span>
        <span class="c1"># sweeps were skipped and fill batch_ch with the corresponding amount of 0s. Should be rare to skip so many</span>
        <span class="c1"># sweep unless very few bytes are read on the USB port.</span>

        <span class="c1"># CASE 1: [0, 0] - No valid header ever found</span>
        <span class="k">if</span> <span class="n">next_header</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># This is the first time we go through process_batch</span>
            <span class="n">index</span><span class="p">,</span> <span class="n">next_header</span> <span class="o">=</span> <span class="n">find_start_batch</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">next_header</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># valid header not found - need more data to get started</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;[WARNING] No valid header found when searching for a start signal for a case [0, 0]&quot;</span><span class="p">)</span>
                <span class="n">rest</span> <span class="o">=</span> <span class="n">data</span>
                <span class="k">return</span> <span class="n">batch_ch</span><span class="p">,</span> <span class="n">next_header</span><span class="p">,</span> <span class="n">rest</span><span class="p">,</span> <span class="n">sweep_count</span><span class="p">,</span> <span class="n">counter_decimation</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Found a valid header. Let&#39;s get started with the main while loop!</span>
                <span class="k">assert</span> <span class="n">next_header</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;start&#39;</span><span class="p">]</span>

        <span class="c1"># CASE 2: [1, N] - The backward search failed previously</span>
        <span class="k">elif</span> <span class="n">next_header</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># The previous batch ended without a valid next header but has a frame_number</span>
            <span class="n">current_frame_number</span> <span class="o">=</span> <span class="n">next_header</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">index</span><span class="p">,</span> <span class="n">next_header</span> <span class="o">=</span> <span class="n">find_start_batch</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>  <span class="c1"># Start searching from the start</span>
            <span class="k">if</span> <span class="n">next_header</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># valid header not found - need more data to get started</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;[WARNING] No valid header found when searching for a start signal for a case [1, N]&quot;</span><span class="p">)</span>
                <span class="n">next_header</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">current_frame_number</span><span class="p">]</span>  <span class="c1"># Restore header</span>
                <span class="n">rest</span> <span class="o">=</span> <span class="n">data</span>
                <span class="k">return</span> <span class="n">batch_ch</span><span class="p">,</span> <span class="n">next_header</span><span class="p">,</span> <span class="n">rest</span><span class="p">,</span> <span class="n">sweep_count</span><span class="p">,</span> <span class="n">counter_decimation</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># Sucess! A valid header was found. Append the required 0s for the skipped sweeps</span>
                <span class="k">assert</span> <span class="n">next_header</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;start&#39;</span><span class="p">]</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;[INFO] Recovered from backward search failure with&quot;</span><span class="p">,</span> <span class="n">next_header</span><span class="p">)</span>
                <span class="n">sweeps_scanned</span> <span class="o">=</span> <span class="p">(</span><span class="n">next_header</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">current_frame_number</span><span class="p">)</span><span class="o">&amp;</span><span class="mh">0xff</span>
                <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sweeps_scanned</span><span class="p">):</span>  <span class="c1"># Add all the required zeros before getting started</span>
                    <span class="k">if</span> <span class="n">counter_decimation</span> <span class="o">==</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;soft_decimate&#39;</span><span class="p">]:</span>
                        <span class="n">signed_data</span> <span class="o">=</span> <span class="n">skipped_data</span>  <span class="c1"># Will append just 0s. Frame is skipped</span>
                        <span class="n">batch_ch</span><span class="p">[</span><span class="s1">&#39;skipped_sweeps&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sweep_count</span><span class="p">)</span>

                        <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;channel_count&#39;</span><span class="p">]):</span>  <span class="c1"># Channels number are 1 based for now</span>
                            <span class="n">batch_ch</span><span class="p">[</span><span class="n">channel</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">signed_data</span><span class="p">[</span><span class="n">channel</span><span class="p">::</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;channel_count&#39;</span><span class="p">]])</span>  <span class="c1"># Data is entangled</span>

                        <span class="c1"># Increment counters</span>
                        <span class="n">counter_decimation</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="n">sweep_count</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># Only count sweeps after decimation</span>
                    <span class="k">else</span><span class="p">:</span>  <span class="c1"># Decimate sweep: should we interpolate the data or drop zeros?</span>
                        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;[INFO] Decimating sweep : </span><span class="si">{}</span><span class="s2">/</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">counter_decimation</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;soft_decimate&#39;</span><span class="p">]))</span>
                        <span class="n">counter_decimation</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">sweeps_scanned</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;[INFO] Done recovering &quot;</span><span class="p">,</span> <span class="n">next_header</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>  <span class="c1"># There is a valid previous header!</span>
        <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># rest+data will be scanned from the start</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;[INFO] Starting with header&quot;</span><span class="p">,</span> <span class="n">next_header</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>  <span class="c1"># [DEBUG] I saw that fail once, not sure why</span>
        <span class="n">current_frame_number</span> <span class="o">=</span> <span class="n">next_header</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">next_header</span><span class="p">)</span>


    <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="nb">bytes</span>
    <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">next_header</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">next_header</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;start&#39;</span><span class="p">]</span>  <span class="c1"># All issues must have been solved before getting to the main loop</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">next_header</span><span class="p">)</span>
        <span class="k">raise</span>
    <span class="k">assert</span> <span class="n">index</span> <span class="o">&gt;=</span> <span class="mi">0</span>  <span class="c1"># Cannot be negative otherwise creates a wreck</span>

    <span class="c1"># 3. Process the batches as long as they are valid.</span>
    <span class="k">while</span> <span class="n">index</span><span class="o">+</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;nbytes_sweep&#39;</span><span class="p">]</span><span class="o">+</span><span class="mi">2</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="ow">and</span> <span class="n">next_header</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;start&#39;</span><span class="p">]:</span>
        <span class="c1"># 3.1 Scoop the next s[&#39;nbytes_sweep&#39;] and the following header</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">[INFO] Reading sweep&quot;</span><span class="p">,</span> <span class="n">current_frame_number</span><span class="p">)</span>
        <span class="n">batch</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="p">:</span><span class="n">index</span><span class="o">+</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;nbytes_sweep&#39;</span><span class="p">]]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">batch</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Debug 2&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;nbytes_sweep&#39;</span><span class="p">])</span>
            <span class="k">raise</span>
        <span class="n">next_header</span> <span class="o">=</span> <span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="o">+</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;nbytes_sweep&#39;</span><span class="p">]],</span> <span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="o">+</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;nbytes_sweep&#39;</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span>

        <span class="c1"># 3.2 First case: the header is valid</span>
        <span class="k">if</span> <span class="n">next_header</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;start&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">next_header</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="p">(</span><span class="n">current_frame_number</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">&amp;</span><span class="mh">0xff</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;[INFO] Successfully read sweep </span><span class="si">{}</span><span class="s2"> starting at index </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">current_frame_number</span><span class="p">,</span> <span class="n">index</span><span class="p">))</span>
            <span class="n">flag_success</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">index</span> <span class="o">+=</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;nbytes_sweep&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span>
            <span class="n">sweeps_scanned</span> <span class="o">=</span> <span class="p">(</span><span class="n">next_header</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">current_frame_number</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span>
            <span class="k">assert</span> <span class="n">sweeps_scanned</span> <span class="o">==</span> <span class="mi">1</span>  <span class="c1"># Debug</span>

        <span class="c1"># Second case: the next_header does not match expectations</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># Drop this sweep as next_header does not match expectations</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;[WARNING] Lost track of sweep starting at </span><span class="si">{}</span><span class="s1"> &#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">index</span><span class="p">))</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;[WARNING] Next header at </span><span class="si">{}</span><span class="s1"> read: </span><span class="si">{}</span><span class="s1"> | Expected: (</span><span class="si">{}</span><span class="s1">, </span><span class="si">{}</span><span class="s1">)&#39;</span>
                      <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">index</span><span class="o">+</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;nbytes_sweep&#39;</span><span class="p">],</span> <span class="n">next_header</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;start&#39;</span><span class="p">],</span> <span class="p">(</span><span class="n">current_frame_number</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">&amp;</span><span class="mh">0xff</span><span class="p">))</span>
            <span class="n">flag_success</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="c1"># Option 1: Look for the start of the correct next_header in the dropped data</span>
            <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;nbytes_sweep&#39;</span><span class="p">])[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>  <span class="c1"># Go in reverse</span>
                <span class="k">try</span><span class="p">:</span>  <span class="c1"># DEBUG</span>
                    <span class="k">if</span> <span class="n">jj</span> <span class="o">==</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;nbytes_sweep&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="c1"># if sweep_data[jj] == s[&#39;start&#39;] and next_frame_number == (current_frame_number+1)&amp;0xff:  # I think this is wrong</span>
                        <span class="k">if</span> <span class="n">batch</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span> <span class="o">==</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;start&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">next_header</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="p">(</span><span class="n">current_frame_number</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">&amp;</span><span class="mh">0xff</span><span class="p">:</span>  <span class="c1"># Check this</span>
                            <span class="n">next_header</span> <span class="o">=</span> <span class="p">[</span><span class="n">batch</span><span class="p">[</span><span class="n">jj</span><span class="p">],</span> <span class="n">next_header</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>  <span class="c1"># Only 1 int16 was lost</span>
                            <span class="k">break</span>

                    <span class="k">elif</span> <span class="n">batch</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span> <span class="o">==</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;start&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">batch</span><span class="p">[</span><span class="n">jj</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="p">(</span><span class="n">current_frame_number</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">&amp;</span><span class="mh">0xff</span><span class="p">:</span>
                        <span class="n">next_header</span> <span class="o">=</span> <span class="p">[</span><span class="n">batch</span><span class="p">[</span><span class="n">jj</span><span class="p">],</span> <span class="n">batch</span><span class="p">[</span><span class="n">jj</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span>  <span class="c1"># Cast batch values to int and put them in a list</span>
                        <span class="k">break</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;DEBUG&quot;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">jj</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">batch</span><span class="p">))</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">next_header</span><span class="p">)</span>
                    <span class="k">assert</span> <span class="mi">0</span>
            <span class="c1"># Process the result of that backward search</span>
            <span class="k">if</span> <span class="n">next_header</span> <span class="o">==</span> <span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;start&#39;</span><span class="p">],</span> <span class="p">(</span><span class="n">current_frame_number</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">]:</span>  <span class="c1"># Valid header!</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;[WARNING] Found header </span><span class="si">{}</span><span class="s2"> at </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">next_header</span><span class="p">,</span> <span class="n">index</span><span class="o">+</span><span class="n">jj</span><span class="p">))</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;[WARNING] Skipping sweep </span><span class="si">{}</span><span class="s2"> from </span><span class="si">{}</span><span class="s2"> to </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">current_frame_number</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">index</span><span class="o">+</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;nbytes_sweep&#39;</span><span class="p">]))</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;[WARNING] Restarting with sweep </span><span class="si">{}</span><span class="s2"> from position </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">next_header</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">index</span><span class="o">+</span><span class="n">jj</span><span class="o">+</span><span class="mi">2</span><span class="p">))</span>
                <span class="n">index</span> <span class="o">+=</span> <span class="n">jj</span> <span class="o">+</span> <span class="mi">2</span> <span class="c1"># Skip the next_header and get ready to scoop s[&#39;nbytes_sweep&#39;] of data</span>
                <span class="n">sweeps_scanned</span> <span class="o">=</span> <span class="p">(</span><span class="n">next_header</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">current_frame_number</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span>
                <span class="k">assert</span> <span class="n">sweeps_scanned</span> <span class="o">==</span> <span class="mi">1</span>  <span class="c1"># Debug</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># Backward pass failed</span>
                <span class="c1"># Option 2: Search for the header forward</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;[WARNING] Failed backward search. Header must have been lost.&quot;</span><span class="p">)</span>
                <span class="n">next_header</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">current_frame_number</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">]</span>  <span class="c1"># Signal that the backward search failed</span>
                <span class="k">assert</span> <span class="n">jj</span> <span class="o">==</span> <span class="mi">0</span>
                <span class="n">index</span> <span class="o">+=</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;nbytes_sweep&#39;</span><span class="p">]</span>  <span class="c1"># Skip the whole &quot;expected&quot; sweep.</span>
                <span class="n">sweeps_scanned</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># This sweep will be ignored</span>
                <span class="sd">&quot;&quot;&quot;[TBR] Previously tried to find forward the next header</span>
<span class="sd">                index, next_header = find_start_batch(data, s, initial_index=index)</span>
<span class="sd">                print(&quot;[WARNING] Current sweep number: {} | Next header count: {}&quot;</span>
<span class="sd">                      .format(current_frame_number, next_header[1]))</span>

<span class="sd">                if next_header[0] == 0:  # Failed to find a valid header forward</span>
<span class="sd">                    index = len(data)  # No rest will be generated</span>
<span class="sd">                    next_header = [0, current_frame_number]  # Communicate</span>
<span class="sd">                    sweeps_scanned = 0  # Skip channel assignement</span>
<span class="sd">                    print(&#39;[WARNING] Next header not found in previous incorrect frame nor rest of frame.&#39;)</span>
<span class="sd">                else:  # Valid header found in forward data</span>
<span class="sd">                    sweeps_scanned = (next_header[1] - current_frame_number) &amp; 0xff  # Could be &gt; 1</span>
<span class="sd">                &quot;&quot;&quot;</span>

        <span class="n">current_frame_number</span> <span class="o">=</span> <span class="n">next_header</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># Ready to read the next sweep</span>

        <span class="c1"># 3.3 Append data if we are not decimating</span>
        <span class="c1">#if counter_decimation == s[&#39;soft_decimate&#39;]:</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sweeps_scanned</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">counter_decimation</span> <span class="o">==</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;soft_decimate&#39;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">flag_success</span><span class="p">:</span>
                    <span class="n">signed_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">batch</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span>  <span class="c1"># Read as int16</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">signed_data</span> <span class="o">=</span> <span class="n">skipped_data</span> <span class="c1"># Will append just 0s. Frame is skipped</span>
                    <span class="n">batch_ch</span><span class="p">[</span><span class="s1">&#39;skipped_sweeps&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sweep_count</span><span class="p">)</span>
    
                <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;channel_count&#39;</span><span class="p">]):</span>  <span class="c1"># Channels number are 1 based for now</span>
                    <span class="n">batch_ch</span><span class="p">[</span><span class="n">channel</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">signed_data</span><span class="p">[</span><span class="n">channel</span><span class="p">::</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;channel_count&#39;</span><span class="p">]])</span>  <span class="c1"># Data is entangled</span>
    
                <span class="c1"># Increment counters</span>
                <span class="n">counter_decimation</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">sweep_count</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># Only count sweeps after decimation</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1"># Decimate sweep: should we interpolate the data or drop zeros?</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;[INFO] Decimating sweep : </span><span class="si">{}</span><span class="s2">/</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">counter_decimation</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;soft_decimate&#39;</span><span class="p">]))</span>
                <span class="n">counter_decimation</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">sweeps_scanned</span> <span class="o">=</span> <span class="mi">0</span>


    <span class="c1"># 4. Finalization</span>
    <span class="c1"># Return numpy arrays rather than lists</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;channel_count&#39;</span><span class="p">]):</span>
        <span class="n">batch_ch</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">batch_ch</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span>
    <span class="n">rest</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="p">:]</span>  <span class="c1"># Get the rest if index &lt; length(data) else []</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">[INFO] There is a rest of length&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">rest</span><span class="p">))</span>
    
    <span class="k">return</span> <span class="n">batch_ch</span><span class="p">,</span> <span class="n">next_header</span><span class="p">,</span> <span class="n">rest</span><span class="p">,</span> <span class="n">sweep_count</span><span class="p">,</span> <span class="n">counter_decimation</span></div>


<div class="viewcode-block" id="calculate_if_data"><a class="viewcode-back" href="../../source/fmcw.html#fmcw.postprocessing.calculate_if_data">[docs]</a><span class="k">def</span> <span class="nf">calculate_if_data</span><span class="p">(</span><span class="n">sweeps</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert the raw data to a differential voltage level. Note that the data is cast from int16 to float64.</span>
<span class="sd">    :param sweeps: Sweeps to consider</span>
<span class="sd">    :param s: Settings dictionary</span>
<span class="sd">    :return: Voltage is returned as a dict with each key being a channel.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">sweeps</span><span class="p">)</span> <span class="o">==</span> <span class="nb">dict</span>
    <span class="n">if_data</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="n">sweeps</span><span class="p">:</span> <span class="c1"># Go through all available channels</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sweeps</span><span class="p">[</span><span class="n">channel</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">*=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;fir_gain&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">**</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;adc_bits&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>  <span class="c1"># No w</span>
        <span class="n">if_data</span><span class="p">[</span><span class="n">channel</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>

    <span class="k">return</span> <span class="n">if_data</span></div>


<div class="viewcode-block" id="calculate_angle_plot"><a class="viewcode-back" href="../../source/fmcw.html#fmcw.postprocessing.calculate_angle_plot">[docs]</a><span class="k">def</span> <span class="nf">calculate_angle_plot</span><span class="p">(</span><span class="n">sweeps</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">tfd_angles</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Perform the data processing to calculate the angular location of objects in a single sweep. The goal is to plot</span>
<span class="sd">    that result afterward, not to process multiple sweeps.</span>

<span class="sd">    :param sweeps: Data from which the angle position will be calculated</span>
<span class="sd">    :param s: Settings dictionary</span>
<span class="sd">    :param tfd_angles: Tuple containing all the bins important for the plotting</span>
<span class="sd">    :return: fxdb</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># WARNING: ONLY 2 CHANNELS SUPPORTED SO FAR</span>
    <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">sweeps</span><span class="p">)</span> <span class="o">==</span> <span class="nb">dict</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">tfd_angles</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">angle_mask</span> <span class="o">=</span> <span class="n">tfd_angles</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>

    <span class="n">fxm</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># If not None need to see sth else</span>
    <span class="k">if</span> <span class="n">fxm</span><span class="p">:</span>
        <span class="n">coefs</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.008161818583356717</span><span class="p">,</span>
                 <span class="o">-</span><span class="mf">0.34386493885120994</span><span class="p">,</span>
                 <span class="mf">0.65613506114879</span><span class="p">,</span>
                 <span class="o">-</span><span class="mf">0.34386493885120994</span><span class="p">,</span>
                 <span class="mf">0.008161818583356717</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">coefs</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">angle_window</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kaiser</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;angle_pad&#39;</span><span class="p">],</span> <span class="mi">150</span><span class="p">)</span>

    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfft</span><span class="p">(</span><span class="n">sweeps</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>  <span class="c1"># Channels indexes are 1 based</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfft</span><span class="p">(</span><span class="n">sweeps</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="c1"># b *= np.exp(-1j*2*np.pi*channel_dl/(s[&#39;c&#39;]/(s[&#39;f0&#39;]+s[&#39;bw&#39;]/2)))</span>
    <span class="n">b</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;channel_offset&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">180</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;swap_chs&#39;</span><span class="p">]:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">fx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;angle_pad&#39;</span><span class="p">]),</span> <span class="n">axes</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">fx</span> <span class="o">=</span> <span class="n">r4_normalize</span><span class="p">(</span><span class="n">fx</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>

    <span class="k">if</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># Calculate the min/max to use with the color bar</span>
        <span class="n">max_range_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;max_range&#39;</span><span class="p">])</span>
        <span class="n">cblim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="mi">20</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fx</span><span class="p">[:</span><span class="n">max_range_i</span><span class="p">,</span> <span class="p">:])))</span> <span class="o">+</span> <span class="mi">10</span>
        <span class="n">cblim</span> <span class="o">=</span> <span class="p">[</span><span class="n">cblim</span><span class="o">-</span><span class="mi">50</span><span class="p">,</span> <span class="n">cblim</span><span class="p">]</span>  <span class="c1"># min max array</span>

    <span class="k">if</span> <span class="n">fxm</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># Apply coefficients ?</span>
        <span class="n">fx</span> <span class="o">=</span> <span class="n">coefs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">fx</span>
    <span class="k">else</span><span class="p">:</span>  <span class="c1"># k is not defined anymore, would have to get it from original files</span>
        <span class="n">fx</span> <span class="o">+=</span> <span class="n">coefs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">fx</span>

    <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;flag_Hanning&#39;</span><span class="p">]:</span>  <span class="c1"># Apply a Hanning window to the peak</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">center</span> <span class="o">=</span> <span class="n">fx</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="k">for</span> <span class="n">freq</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">fx</span><span class="p">):</span>  <span class="c1"># Transpose for convenience</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">freq</span><span class="p">))</span>  <span class="c1"># Find the index of the max</span>
            <span class="n">window</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">angle_window</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="o">-</span><span class="n">center</span> <span class="o">-</span> <span class="n">m</span><span class="p">)))</span>  <span class="c1"># Center window on max</span>
            <span class="n">freq</span> <span class="o">*=</span> <span class="n">window</span>  <span class="c1"># Apply the window</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>
        <span class="n">fx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>  <span class="c1"># Get back to original shape</span>

    <span class="n">fx</span> <span class="o">=</span> <span class="n">fx</span><span class="p">[</span><span class="n">angle_mask</span><span class="p">]</span>
    <span class="n">fxdb</span> <span class="o">=</span> <span class="mi">20</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fx</span><span class="p">))</span>


    <span class="k">return</span> <span class="n">fxdb</span></div>


<div class="viewcode-block" id="calculate_range_time"><a class="viewcode-back" href="../../source/fmcw.html#fmcw.postprocessing.calculate_range_time">[docs]</a><span class="k">def</span> <span class="nf">calculate_range_time</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">single_sweep</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Take a single sweep and calculate the distances of all signals. All the channels are averaged in a single virtual</span>
<span class="sd">    channel. While this is not super good practice, it is mostly okay given how far the objects are in comparison to the</span>
<span class="sd">    distance between antennas.</span>
<span class="sd">    :param ch: dict containing the sweep data for each channel</span>
<span class="sd">    :param s: Settings dictionary</span>
<span class="sd">    :param single_sweep: Sweep to select in the dictionary in case there are actually multiple of them. To be removed.</span>
<span class="sd">    :return: im, nb_sweeps, max_range_index</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># WARNING: ONLY USING CHANNEL 2 FOR THAT</span>
    <span class="c1"># Take the average of all channels</span>
    <span class="n">sweeps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ch</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;active_channels&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>  <span class="c1"># There is at least one active channel</span>
    <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;active_channels&#39;</span><span class="p">]:</span>
        <span class="n">sweeps</span> <span class="o">+=</span> <span class="n">ch</span><span class="p">[</span><span class="n">channel</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
    <span class="n">sweeps</span> <span class="o">/=</span>  <span class="n">s</span><span class="p">[</span><span class="s1">&#39;channel_count&#39;</span><span class="p">]</span>  <span class="c1"># Becomes a single 2D numpy array</span>


    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ch</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;active_channels&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># Only 1 sweep was given</span>
        <span class="n">nb_sweeps</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">single_sweep</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>  <span class="c1"># Extract a sweep from an ndarray of them</span>
        <span class="k">if</span> <span class="n">single_sweep</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">sweeps</span> <span class="o">=</span> <span class="n">sweeps</span><span class="p">[</span><span class="n">single_sweep</span><span class="p">]</span>  <span class="c1"># Using last sweep only</span>
            <span class="n">nb_sweeps</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">single_sweep</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nb_sweeps</span> <span class="o">=</span> <span class="n">sweeps</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># Number of sweeps</span>
            <span class="n">single_sweep</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">sweep_length</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;sweep_length&#39;</span><span class="p">]</span>

    <span class="sd">&quot;&quot;&quot;[TBR] Potentially subtract the background &amp; all&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;subtract_background&#39;</span><span class="p">]:</span>
        <span class="n">background</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sweep_length</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sweeps</span><span class="p">)):</span>
                <span class="n">x</span> <span class="o">+=</span> <span class="n">sweeps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
            <span class="n">background</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">sweeps</span><span class="p">))</span>

    <span class="n">max_range_index</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sweep_length</span> <span class="o">*</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;max_range&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;range_adc&#39;</span><span class="p">])</span>
    <span class="n">max_range_index</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">max_range_index</span><span class="p">,</span> <span class="n">sweep_length</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>

    <span class="n">im</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">max_range_index</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">nb_sweeps</span><span class="p">))</span>
    <span class="n">w</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">sweep_length</span> <span class="k">if</span> <span class="n">single_sweep</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">kaiser</span><span class="p">(</span><span class="n">sweep_length</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;kaiser_beta&#39;</span><span class="p">])</span>

    <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nb_sweeps</span><span class="p">):</span>
        <span class="n">sw</span> <span class="o">=</span> <span class="n">sweeps</span> <span class="k">if</span> <span class="n">single_sweep</span> <span class="k">else</span> <span class="n">sweeps</span><span class="p">[</span><span class="n">e</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;subtract_clutter&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">e</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">sw</span> <span class="o">=</span> <span class="p">[</span><span class="n">sw</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">sweeps</span><span class="p">[</span><span class="n">e</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sweep_length</span><span class="p">)]</span>
        <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;subtract_background&#39;</span><span class="p">]:</span>
            <span class="n">sw</span> <span class="o">=</span> <span class="p">[</span><span class="n">sw</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">background</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sweep_length</span><span class="p">)]</span>

        <span class="n">sw</span> <span class="o">=</span> <span class="p">[</span><span class="n">sw</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">w</span><span class="p">))]</span>  <span class="c1"># Take a Kaiser window of the sweep</span>
        <span class="n">fy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfft</span><span class="p">(</span><span class="n">sw</span><span class="p">)[</span><span class="mi">3</span><span class="p">:</span><span class="n">max_range_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>  <span class="c1"># FFT of the sweep</span>
        <span class="n">fy</span> <span class="o">=</span> <span class="mi">20</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">((</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;adc_ref&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;adc_bits&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;fir_gain&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">max_range_index</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fy</span><span class="p">))</span>
        <span class="n">fy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">fy</span><span class="p">,</span> <span class="o">-</span><span class="mi">100</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">))</span>
        <span class="n">im</span><span class="p">[:,</span> <span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">fy</span><span class="p">)</span>
        <span class="n">im</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">fy</span><span class="p">)</span> <span class="k">if</span> <span class="n">single_sweep</span> <span class="k">else</span> <span class="n">im</span>

    <span class="k">if</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">cblim</span> <span class="o">=</span> <span class="p">[</span><span class="nb">min</span><span class="p">(</span><span class="n">im</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span>


    <span class="k">return</span> <span class="n">im</span><span class="p">,</span> <span class="n">nb_sweeps</span><span class="p">,</span> <span class="n">max_range_index</span></div>


<div class="viewcode-block" id="find_start"><a class="viewcode-back" href="../../source/fmcw.html#fmcw.postprocessing.find_start">[docs]</a><span class="k">def</span> <span class="nf">find_start</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find a valid start header in a binary file by looking for two valid headers separated by the proper length of data.</span>
<span class="sd">    Given the simplicity of the system, it is not possible to guarantee that this data is &quot;legit&quot; as valid headers could</span>
<span class="sd">    be coming from random data. However, it is very unlikely.</span>
<span class="sd">    :param f: File handle</span>
<span class="sd">    :param start: Start signal to look for</span>
<span class="sd">    :param s: Settings dictionary</span>
<span class="sd">    :return: The current file.seek() index at which the valid data starts and the corresponding frame number. It is</span>
<span class="sd">    coded on a single byte, so expect it to roll over after 255 is reached.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">done</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">while</span> <span class="ow">not</span> <span class="n">done</span><span class="p">:</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">r</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>  <span class="c1"># Would indicate that we have reached the EOF</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="n">r</span> <span class="o">!=</span> <span class="n">start</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="k">else</span><span class="p">:</span>  <span class="c1"># Found start character</span>
            <span class="n">current_frame_number</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">done</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">current_position</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span>
            <span class="c1"># Verify that what follows are full sweeps</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;nbytes_sweep&#39;</span><span class="p">])</span>  <span class="c1"># Read a whole sweep</span>
                <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="n">start</span><span class="p">:</span>
                    <span class="n">done</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">next_frame_number</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">next_frame_number</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">return</span>
                <span class="k">if</span> <span class="n">next_frame_number</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">current_frame_number</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="n">j</span><span class="p">:</span>
                    <span class="n">done</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">f</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">current_position</span><span class="p">)</span>  <span class="c1"># Go back to just before the data</span>
    <span class="k">return</span> <span class="n">current_position</span><span class="p">,</span> <span class="n">current_frame_number</span></div>


<div class="viewcode-block" id="import_data"><a class="viewcode-back" href="../../source/fmcw.html#fmcw.postprocessing.import_data">[docs]</a><span class="k">def</span> <span class="nf">import_data</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">first_frame</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">samples</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Import the data from a binary file. This was the source inspiration for process_batch, which is more up to date and</span>
<span class="sd">    deal with real time data. As a result, this might not be fully up to date.</span>
<span class="sd">    :param f: File handle</span>
<span class="sd">    :param start: Start signal for the headers</span>
<span class="sd">    :param first_frame: Get the current frame number read from find_start</span>
<span class="sd">    :param s: Settings dictionary</span>
<span class="sd">    :param samples: Legacy argument, useless</span>
<span class="sd">    :param verbose: Print a lot more info</span>
<span class="sd">    :return:</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">counter_decimation</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">signal</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;start&#39;</span><span class="p">]</span>
    <span class="n">sweep_count</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">current_frame_number</span> <span class="o">=</span> <span class="n">first_frame</span>
    <span class="c1"># The data will be stored in a dict of lists, the keys being the channel number</span>
    <span class="n">data</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;channel_count&#39;</span><span class="p">]):</span>
        <span class="n">data</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">data</span><span class="p">[</span><span class="s1">&#39;skipped_sweeps&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Stores the skipped frames for both channels</span>

    <span class="k">while</span> <span class="n">samples</span> <span class="o">==</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">samples</span><span class="p">:</span>
        <span class="c1"># Read the start signal and the the frame_number</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">[INFO] Current header [</span><span class="si">{}</span><span class="s2">, </span><span class="si">{}</span><span class="s2">] | sweep_data starting at: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">current_frame_number</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">tell</span><span class="p">()))</span>
        <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
        <span class="n">sweep_data</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;nbytes_sweep&#39;</span><span class="p">])</span>  <span class="c1"># Block read</span>
        <span class="n">t1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sweep_data</span><span class="p">)</span> <span class="o">!=</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;nbytes_sweep&#39;</span><span class="p">]:</span>
            <span class="k">break</span>  <span class="c1"># No more data, we have reached the end of the file</span>

        <span class="c1"># Read the header</span>
        <span class="n">signal</span><span class="p">,</span> <span class="n">next_frame_number</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># Should get the next signal and frame_number</span>
        <span class="n">restart</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">signal</span> <span class="o">!=</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;start&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;[WARNING] Lost track of start at </span><span class="si">{}</span><span class="s1"> | Next header read: [</span><span class="si">{}</span><span class="s1">, </span><span class="si">{}</span><span class="s1">] but expected: [</span><span class="si">{}</span><span class="s1">, </span><span class="si">{}</span><span class="s1">]&#39;</span>
                  <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">tell</span><span class="p">(),</span> <span class="n">signal</span><span class="p">,</span> <span class="n">next_frame_number</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;start&#39;</span><span class="p">],</span> <span class="p">(</span><span class="n">current_frame_number</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">&amp;</span><span class="mh">0xff</span><span class="p">))</span>
            <span class="n">restart</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">restart</span> <span class="o">==</span> <span class="kc">False</span> <span class="ow">and</span> <span class="n">current_frame_number</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">next_frame_number</span> <span class="o">!=</span> <span class="p">(</span><span class="n">current_frame_number</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">&amp;</span><span class="mh">0xff</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;[WARNING] Lost a sweep at </span><span class="si">{}</span><span class="s1"> | Next header read: [</span><span class="si">{}</span><span class="s1">, </span><span class="si">{}</span><span class="s1">] but expected: [</span><span class="si">{}</span><span class="s1">, </span><span class="si">{}</span><span class="s1">]&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">tell</span><span class="p">(),</span> <span class="n">signal</span><span class="p">,</span> <span class="n">next_frame_number</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;start&#39;</span><span class="p">],</span> <span class="p">(</span><span class="n">current_frame_number</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">&amp;</span><span class="mh">0xff</span><span class="p">))</span>
                <span class="c1">#assert 1==0</span>
                <span class="n">restart</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">restart</span><span class="p">:</span> <span class="c1"># Find the nearest start flag, looking at the latest data first</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span>
            <span class="c1"># Check in the data if a valid header can be found</span>
            <span class="n">flag_success</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;nbytes_sweep&#39;</span><span class="p">])[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>  <span class="c1"># Go in reverse</span>
                <span class="k">if</span> <span class="n">jj</span> <span class="o">==</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;nbytes_sweep&#39;</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">sweep_data</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span> <span class="o">==</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;start&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">signal</span> <span class="o">==</span> <span class="p">(</span><span class="n">current_frame_number</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">:</span>  <span class="c1"># Check this if getting the chance</span>
                        <span class="n">flag_success</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">break</span>
                <span class="k">elif</span> <span class="n">sweep_data</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span> <span class="o">==</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;start&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">sweep_data</span><span class="p">[</span><span class="n">jj</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="p">(</span><span class="n">current_frame_number</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">&amp;</span><span class="mh">0xff</span><span class="p">:</span>
                    <span class="n">flag_success</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">break</span>

            <span class="k">if</span> <span class="n">flag_success</span><span class="p">:</span>  <span class="c1"># The next header was found in the previous sweep data: some data was dropped!</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;[WARNING] Found next header [</span><span class="si">{}</span><span class="s2">, </span><span class="si">{}</span><span class="s2">] at position </span><span class="si">{}</span><span class="s2"> in the sweep_data of length </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sweep_data</span><span class="p">[</span><span class="n">jj</span><span class="p">],</span> <span class="n">sweep_data</span><span class="p">[</span><span class="n">jj</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">jj</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;nbytes_sweep&#39;</span><span class="p">]))</span>
                <span class="c1"># Sanity check:</span>
                <span class="n">f</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">pos</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;nbytes_sweep&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">jj</span><span class="p">)</span>
                <span class="n">signal</span><span class="p">,</span> <span class="n">next_frame_number</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># Drop previous sweep</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;[WARNING] Jumped to </span><span class="si">{}</span><span class="s1">, moved by </span><span class="si">{}</span><span class="s1"> byte&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">tell</span><span class="p">(),</span> <span class="n">f</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span><span class="o">-</span><span class="n">pos</span><span class="p">))</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;[WARNING] Skipping sweep </span><span class="si">{}</span><span class="s2">. New header: [</span><span class="si">{}</span><span class="s2">, </span><span class="si">{}</span><span class="s2">] (overall sweep count: </span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">current_frame_number</span><span class="p">,</span> <span class="n">signal</span><span class="p">,</span> <span class="n">next_frame_number</span><span class="p">,</span> <span class="n">sweep_count</span><span class="p">))</span>
                <span class="c1"># Process the new location</span>
                <span class="n">current_frame_number</span> <span class="o">=</span> <span class="n">next_frame_number</span>

                <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span><span class="o">-</span><span class="n">pos</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># Somehow the previous frame was s[&#39;nbytes_sweep&#39;] and did not contain an issue</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;[ERROR] Why was a correct header not found in the previous data?&quot;</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;[ERROR] Next header not found in previous incorrect frame. Where is it?&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">current_frame_number</span> <span class="o">=</span> <span class="n">next_frame_number</span>


        <span class="k">if</span> <span class="n">counter_decimation</span> <span class="o">==</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;soft_decimate&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;[INFO] Using this sweep : </span><span class="si">{}</span><span class="s2">/</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">counter_decimation</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;soft_decimate&#39;</span><span class="p">]))</span>
            <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
            <span class="n">signed_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">sweep_data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span>  <span class="c1"># Does everything at once</span>
            <span class="n">t1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">restart</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;[WARNING] Due to restart, appending zeros for sweep </span><span class="si">{}</span><span class="s2"> (overall sweep counter: </span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">current_frame_number</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">sweep_count</span><span class="p">))</span>
                <span class="n">signed_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;nbytes_sweep&#39;</span><span class="p">]</span><span class="o">//</span><span class="mi">2</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span>
                <span class="n">data</span><span class="p">[</span><span class="s1">&#39;skipped_sweeps&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sweep_count</span><span class="p">)</span>
            <span class="c1"># Append channel data to respective list</span>
            <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;channel_count&#39;</span><span class="p">]):</span> <span class="c1"># Channels number are 1 based for now</span>
                <span class="n">data</span><span class="p">[</span><span class="n">channel</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">signed_data</span><span class="p">[</span><span class="n">channel</span><span class="p">::</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;channel_count&#39;</span><span class="p">]])</span>
            <span class="c1">#print(data[1][0][:10])</span>
            <span class="c1">#print(data[2][0][:10])</span>
            <span class="c1">#assert not np.array_equal(data[1], data[2])</span>
            <span class="n">sweep_count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">counter_decimation</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># Decimate sweep: should we interpolate the data or drop zeros?</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;[INFO] Decimating sweep : </span><span class="si">{}</span><span class="s2">/</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">counter_decimation</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;soft_decimate&#39;</span><span class="p">]))</span>
            <span class="n">counter_decimation</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c1"># Return numpy arrays rather than lists</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;channel_count&#39;</span><span class="p">]):</span>
        <span class="n">data</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">data</span></div>


<div class="viewcode-block" id="compare_ndarrays"><a class="viewcode-back" href="../../source/fmcw.html#fmcw.postprocessing.compare_ndarrays">[docs]</a><span class="k">def</span> <span class="nf">compare_ndarrays</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Check if two arrays are equivalent or not with additional details</span>
<span class="sd">    Helper function written to find quickly why two arrays are not equal element wise.</span>
<span class="sd">    :param a: Array 1</span>
<span class="sd">    :param b: Array 2</span>
<span class="sd">    :return: Void. An exception is raised if a difference between the two arrays have been found.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Type: </span><span class="si">{}</span><span class="s2"> | </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="nb">type</span><span class="p">(</span><span class="n">b</span><span class="p">)))</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">type</span><span class="p">(</span><span class="n">b</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Arrays are not of the same type&quot;</span><span class="p">)</span>
    
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Shape: </span><span class="si">{}</span><span class="s2"> | </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Arrays do not have the same shape&quot;</span><span class="p">)</span>
    
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Data type: </span><span class="si">{}</span><span class="s2"> | </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">b</span><span class="o">.</span><span class="n">dtype</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Array elements do not have the same type&quot;</span><span class="p">)</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">a</span><span class="o">-</span><span class="n">b</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">index_c_non_zero</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">))</span> <span class="k">if</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Indexes where the difference is not 0 (count: </span><span class="si">{}</span><span class="s2">):&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">index_c_non_zero</span><span class="p">)))</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">index_c_non_zero</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span></div>


<div class="viewcode-block" id="subtract_background"><a class="viewcode-back" href="../../source/fmcw.html#fmcw.postprocessing.subtract_background">[docs]</a><span class="k">def</span> <span class="nf">subtract_background</span><span class="p">(</span><span class="n">channel_data</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;DEPRECATED?</span>
<span class="sd">    Subtract the mean to a list of sweeps and multiply the result by the weights w. One thing to note, is that sweeps</span>
<span class="sd">    full of zeros (coming from corrupted usb data) are left invariant.</span>
<span class="sd">    :param channel_data: dict of channels containing the sweep data as numpy arrays</span>
<span class="sd">    :param w: weights to apply to the array of sweeps</span>
<span class="sd">    :param data: Not sure</span>
<span class="sd">    :return: Updated channel_data</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">zero_sweep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">channel_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span>
    <span class="c1"># Subtract background from the channels data, which are numpy arrays</span>
    <span class="c1"># Input is the data dictionnary, output is the list of processed data</span>
    <span class="n">background</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">channel_data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">channel_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;skipped_sweeps&#39;</span><span class="p">]))</span>
    <span class="n">channel_data</span> <span class="o">=</span> <span class="n">w</span><span class="o">*</span><span class="p">(</span><span class="n">channel_data</span> <span class="o">-</span> <span class="n">background</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">skipped_frame</span> <span class="ow">in</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;skipped_sweeps&#39;</span><span class="p">]:</span>
        <span class="n">channel_data</span><span class="p">[</span><span class="n">skipped_frame</span><span class="p">]</span> <span class="o">=</span> <span class="n">zero_sweep</span>
    <span class="k">return</span> <span class="n">channel_data</span></div>


<div class="viewcode-block" id="subtract_clutter"><a class="viewcode-back" href="../../source/fmcw.html#fmcw.postprocessing.subtract_clutter">[docs]</a><span class="k">def</span> <span class="nf">subtract_clutter</span><span class="p">(</span><span class="n">channel_data</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">clutter_averaging</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;DEPRECATED?</span>
<span class="sd">    Subtract to a sweep the average of the previous clutter_averaging sweeps. It&#39;s some kind of moving average. The</span>
<span class="sd">    goal is to perform motion detection a lot more easily.</span>
<span class="sd">    :param channel_data: dict of channels containing the sweep data as numpy arrays</span>
<span class="sd">    :param w: weights to apply to the array of sweeps</span>
<span class="sd">    :param data: Not sure</span>
<span class="sd">    :param clutter_averaging: Number of previous sweeps to average before subtracting them to the current one.</span>
<span class="sd">    :return:</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">zero_sweep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">channel_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">clutter_averaging</span><span class="p">,</span> <span class="n">channel_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>  <span class="c1"># Padding for the first clutter_averaging sweeps</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">channel_data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;skipped_sweeps&#39;</span><span class="p">]))</span>

    <span class="c1"># Build the indexes to use for the clutter subtraction</span>
    <span class="n">last_good_indexes</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">deque</span><span class="p">(</span><span class="n">maxlen</span><span class="o">=</span><span class="n">clutter_averaging</span><span class="p">)</span>  <span class="c1"># Deque stored the last meaningful sweeps</span>
    <span class="n">last_good_indexes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># Assume the first sweep is okay</span>
    <span class="n">subtract_channel_data</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">sweep_number</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">channel_data</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">sweep_number</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;skipped_sweeps&#39;</span><span class="p">]):</span>
            <span class="n">subtract_channel_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">zero_sweep</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">accumulator_channel_data</span> <span class="o">=</span> <span class="n">zero_sweep</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>  <span class="c1"># Temporarily switching to the float space</span>

            <span class="c1"># CUSTOM WEIGHTS FOR MOVING AVERAGE</span>
            <span class="c1"># WARNING: index 0 carries the oldest element in the deque, you probably want a lower weight on it.</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">last_good_indexes</span><span class="p">))]</span>
            <span class="c1"># weights = [1/(len(last_good_indexes)-index) for index in range(len(last_good_indexes))]</span>
            <span class="k">if</span> <span class="n">weights</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">weights</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;[WARNING] Currently weighting the oldest sweeps more than the youngest. Are you sure?&quot;</span><span class="p">)</span>
            <span class="c1"># print(weights)</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">last_good_indexes</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">last_good_indexes</span><span class="p">):</span>
                <span class="n">accumulator_channel_data</span> <span class="o">+=</span> <span class="n">weights</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">*</span><span class="n">channel_data</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
            <span class="c1"># if len(last_good_indexes):</span>
                <span class="c1"># print(&quot;[WARNING] Divide by zero at &quot;, ii)</span>
            <span class="n">accumulator_channel_data</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>  <span class="c1"># Divide by the sum of the weights used</span>
            <span class="c1"># Sanity check, verify that casting back to np.int16 is seamless</span>
            <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">accumulator_channel_data</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">**</span> <span class="mi">16</span>
            <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">accumulator_channel_data</span><span class="p">)</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">2</span> <span class="o">**</span> <span class="mi">16</span>
            <span class="n">subtract_channel_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">accumulator_channel_data</span><span class="p">)</span>
            <span class="n">last_good_indexes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sweep_number</span><span class="p">)</span>
    <span class="c1"># Cast back to np.int16</span>
    <span class="n">subtract_channel_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">subtract_channel_data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">subtract_channel_data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">channel_data</span> <span class="o">=</span> <span class="n">w</span><span class="o">*</span><span class="p">(</span><span class="n">channel_data</span> <span class="o">-</span> <span class="n">subtract_channel_data</span><span class="p">)</span>
    <span class="c1">#assert np.array_equal(channel_data_2[0], w*channel_data[0])  # Verify that the first item did not get subtracted anything</span>
    <span class="k">return</span> <span class="n">channel_data</span></div>


<div class="viewcode-block" id="Writer"><a class="viewcode-back" href="../../source/fmcw.html#fmcw.postprocessing.Writer">[docs]</a><span class="k">class</span> <span class="nc">Writer</span><span class="p">(</span><span class="n">Thread</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Writer object that writes data to file. Created as a separate thread fed from a queue, so it&#39;s not blocking.</span>
<span class="sd">    Nothing special about it. Comes in twpo flavors:</span>
<span class="sd">    - Writer for binary files</span>
<span class="sd">    - Writer for csv files</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;latin1&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create the files (settings, binary log and csv log). Uniqueness is ensured by a timestamp prefix.</span>

<span class="sd">        :param queue: Input queue from which the data will be read. If the queue times out, the thread will terminate.</span>
<span class="sd">        :param s: Settings dictionary</span>
<span class="sd">        :param encoding: Depending on its value, a writer to binary file or csv file is created.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Thread</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>  <span class="c1"># Mandatory call to the super constructor</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">queue</span> <span class="o">=</span> <span class="n">queue</span>  <span class="c1"># input queue</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">encoding</span> <span class="o">=</span> <span class="n">encoding</span>  <span class="c1"># type of writer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wrote</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Number of byte or lines written</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">encoding</span> <span class="o">==</span> <span class="s1">&#39;latin1&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;path_raw_log&#39;</span><span class="p">],</span> <span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">encoding</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">encoding</span> <span class="o">==</span> <span class="s1">&#39;csv&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;path_csv_log&#39;</span><span class="p">],</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">writer</span> <span class="o">=</span> <span class="n">csv</span><span class="o">.</span><span class="n">writer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">writer</span><span class="o">.</span><span class="n">writerow</span><span class="p">([</span><span class="s1">&#39;Timestamp&#39;</span><span class="p">,</span> <span class="s1">&#39;Sweep number&#39;</span><span class="p">,</span> <span class="s1">&#39;Channel&#39;</span><span class="p">,</span> <span class="s1">&#39;Data&#39;</span><span class="p">])</span>  <span class="c1"># Add a header</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">encoding</span> <span class="o">==</span> <span class="s1">&#39;settings&#39;</span><span class="p">:</span>
            <span class="c1"># Initialize the settings file and write the settings to file with csv.DictWriter</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;path_settings&#39;</span><span class="p">],</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>  <span class="c1"># Write the settings to file</span>
                <span class="n">writer</span> <span class="o">=</span> <span class="n">csv</span><span class="o">.</span><span class="n">DictWriter</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">fieldnames</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
                <span class="n">writer</span><span class="o">.</span><span class="n">writeheader</span><span class="p">()</span>
                <span class="n">writer</span><span class="o">.</span><span class="n">writerow</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;[INFO] Wrote the settings to </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;path_settings&#39;</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;[ERROR] File encoding method </span><span class="si">{}</span><span class="s1"> unknown&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">encoding</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timeout</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;timeout&#39;</span><span class="p">]</span>


<div class="viewcode-block" id="Writer.run"><a class="viewcode-back" href="../../source/fmcw.html#fmcw.postprocessing.Writer.run">[docs]</a>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Process the data from the queue and write it to file.</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeout</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">Empty</span><span class="p">:</span>  <span class="c1"># The queue has timed out. Not supposed to happen</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">encoding</span> <span class="o">==</span> <span class="s1">&#39;csv&#39;</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;[WARNING] </span><span class="si">{}</span><span class="s1"> Writer timed out after </span><span class="si">{}</span><span class="s1"> s without data | Wrote </span><span class="si">{}</span><span class="s1"> numbers to file&#39;</span>
                          <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">encoding</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeout</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrote</span><span class="p">))</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">encoding</span> <span class="o">==</span> <span class="s1">&#39;latin1&#39;</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;[WARNING] </span><span class="si">{}</span><span class="s1"> Writer timed out after </span><span class="si">{}</span><span class="s1"> s without data | Wrote </span><span class="si">{}</span><span class="s1"> row to file&#39;</span>
                          <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">encoding</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeout</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrote</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
                <span class="k">return</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># A &#39;&#39; signal was intentionally put to queue to indicate the end of the recording</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">[INFO] Done after writing </span><span class="si">{:,}</span><span class="s1"> rows to file&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wrote</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
                <span class="k">return</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">encoding</span> <span class="o">==</span> <span class="s1">&#39;latin1&#39;</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">encoding</span> <span class="o">==</span> <span class="s1">&#39;csv&#39;</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">writer</span><span class="o">.</span><span class="n">writerow</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">wrote</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="move_figure"><a class="viewcode-back" href="../../source/fmcw.html#fmcw.postprocessing.move_figure">[docs]</a><span class="k">def</span> <span class="nf">move_figure</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">number</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Move a figure to position (x, y) of the screen determined by the figure &quot;number&quot;. Only 3 positions supported.</span>
<span class="sd">    DO NOT REALY ON THIS FUNCTION. CANNOT BE GENERALIZED TO OTHER USE CASES THAN WHAT IT WAS DESIGNED FOR.</span>
<span class="sd">    Basically, only used it with Qt5Agg. Did not try other backends and the code is not complete for it. They are slower</span>
<span class="sd">    than Qt when I tried, so not relevant. All units are px</span>
<span class="sd">    :param f: Figure handle</span>
<span class="sd">    :param number: Figure number. Only handles 3 different positions on screen, all 3 horizontal.</span>
<span class="sd">    :return: Void</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">max_width</span> <span class="o">=</span> <span class="mi">1900</span>  <span class="c1"># Ideally, should find the screen dimensions in a backend neutral way</span>
    <span class="n">width</span> <span class="o">=</span> <span class="mi">600</span>  <span class="c1"># Width of the figure</span>
    <span class="n">width_pad</span> <span class="o">=</span> <span class="mi">75</span>  <span class="c1"># Separation between the figures</span>
    <span class="n">height</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">width</span><span class="o">*</span><span class="mi">550</span><span class="o">/</span><span class="mi">640</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># (1, 1) is upper left corner. The coordinates are 1 indexed, so (0, 0) will raise an exception.</span>
    <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">number</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">width</span> <span class="o">+</span> <span class="n">width_pad</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">number</span> <span class="o">&lt;=</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Only 3 plots can be displayed horizontally&#39;</span><span class="p">)</span>

    <span class="n">backend</span> <span class="o">=</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">get_backend</span><span class="p">()</span>  <span class="c1"># Only works with Qt(5?)(Agg?) anyway</span>
    <span class="c1"># print(&quot;Backend is&quot;, backend)</span>
    <span class="k">if</span> <span class="n">backend</span> <span class="o">==</span> <span class="s1">&#39;TkAgg&#39;</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">window</span><span class="o">.</span><span class="n">maxsize</span><span class="p">())</span>
        <span class="n">f</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">window</span><span class="o">.</span><span class="n">wm_geometry</span><span class="p">(</span><span class="s2">&quot;+</span><span class="si">%d</span><span class="s2">+</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">backend</span> <span class="o">==</span> <span class="s1">&#39;WXAgg&#39;</span><span class="p">:</span>
        <span class="n">f</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">window</span><span class="o">.</span><span class="n">SetPosition</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>  <span class="c1"># Qt5Agg</span>
        <span class="n">f</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">window</span><span class="o">.</span><span class="n">setGeometry</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The GUI&#39;s location is now&quot;</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">window</span><span class="o">.</span><span class="n">geometry</span><span class="p">())</span></div>


<div class="viewcode-block" id="if_display"><a class="viewcode-back" href="../../source/fmcw.html#fmcw.postprocessing.if_display">[docs]</a><span class="k">class</span> <span class="nc">if_display</span><span class="p">(</span><span class="n">mp</span><span class="o">.</span><span class="n">Process</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sub-process for displaying the IF (Intermediate Frequency) data. These raw values coming out of the ADC (after</span>
<span class="sd">    FPGA filtering) are (almost) what make up the sweeps. There is a little bit of post-processing but not much.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tfd_angles</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">data_accessible</span><span class="p">,</span> <span class="n">new_sweep_if</span><span class="p">,</span> <span class="n">sweep_to_display</span><span class="p">,</span> <span class="n">time_stamp</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Nothing too special here. Store a bunch of information.</span>
<span class="sd">        :param tfd_angles: x axis data</span>
<span class="sd">        :param s: Settings dictionary</span>
<span class="sd">        :param data_accessible: shared mp.Event that acts as a Lock when the sweep data is being updated.</span>
<span class="sd">        :param new_sweep_if: shared mp.Event that signals when a new sweep is ready to be plotted for its IF.</span>
<span class="sd">        :param sweep_to_display: data to be displayed</span>
<span class="sd">        :param time_stamp: shared mp.Array that contains a few timestamp infos</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mp</span><span class="o">.</span><span class="n">Process</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>  <span class="c1"># Calling super constructor - mandatory</span>
        <span class="c1"># Create the window</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tfd_angles</span> <span class="o">=</span> <span class="n">tfd_angles</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">s</span> <span class="o">=</span> <span class="n">s</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">previous_sweep_counter</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;refresh_stride&#39;</span><span class="p">]</span> <span class="c1"># Virtual initial condition</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_accessible</span> <span class="o">=</span> <span class="n">data_accessible</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">new_sweep_if</span> <span class="o">=</span> <span class="n">new_sweep_if</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sweep_to_display</span> <span class="o">=</span> <span class="n">sweep_to_display</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time_stamp</span> <span class="o">=</span> <span class="n">time_stamp</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timing</span> <span class="o">=</span> <span class="p">[]</span>

<div class="viewcode-block" id="if_display.run"><a class="viewcode-back" href="../../source/fmcw.html#fmcw.postprocessing.if_display.run">[docs]</a>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;IF process loop</span>

<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Create the figure object. Does not work when done in __init__ for some reason</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">window</span> <span class="o">=</span> <span class="n">if_time_domain_animation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tfd_angles</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">blit</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Main loop. Exits when the parent process terminates the process</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="c1"># 1. Wait for the data flag to be set</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data_accessible</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">new_sweep_if</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>

            <span class="c1"># 2. Retrieve the latest data and make a copy of it</span>
            <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sweep_to_display</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span>  <span class="c1"># Makes a copy of that shared memory</span>
            <span class="n">time_stamp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time_stamp</span><span class="p">)</span>  <span class="c1"># Same here, make a copy of the shared memory</span>

            <span class="c1"># 3. Reshape the sweep data as it had to be fit in a static, 1D, C-style array.</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;channel_count&#39;</span><span class="p">],</span>
                               <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;t_sweep&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;if_amplifier_bandwidth&#39;</span><span class="p">])))</span>
            <span class="n">data</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span><span class="n">arr</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;active_channels&#39;</span><span class="p">])}</span>  <span class="c1"># dict for compatibility</span>

            <span class="c1"># 4. Process the IF data</span>
            <span class="n">if_data</span> <span class="o">=</span> <span class="n">calculate_if_data</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">)</span>

            <span class="c1"># 5. Sanity checks: did we skip some refreshes for being too slow?</span>
            <span class="n">sweeps_skipped</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">((</span><span class="n">time_stamp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">previous_sweep_counter</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;refresh_stride&#39;</span><span class="p">]))</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">sweeps_skipped</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="c1"># Some refreshes were skipped - not good!!</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;[WARNING] Refresh rate cannot be sustained for IF data | [</span><span class="si">{}</span><span class="s2">; </span><span class="si">{}</span><span class="s2">[ (total: </span><span class="si">{}</span><span class="s2">) were skipped&quot;</span>
                      <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">previous_sweep_counter</span><span class="p">,</span>
                              <span class="bp">self</span><span class="o">.</span><span class="n">previous_sweep_counter</span><span class="o">+</span><span class="n">sweeps_skipped</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;refresh_stride&#39;</span><span class="p">],</span>
                              <span class="n">sweeps_skipped</span><span class="p">))</span>

            <span class="c1"># 6. Update the figure</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">window</span><span class="o">.</span><span class="n">update_plot</span><span class="p">(</span><span class="n">if_data</span><span class="p">,</span> <span class="n">time_stamp</span><span class="p">)</span>

            <span class="c1"># 7. Set the necessary counters and flags</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">previous_sweep_counter</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">time_stamp</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">new_sweep_if</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">timing</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span> <span class="o">-</span> <span class="n">t0</span><span class="p">)</span></div>
            <span class="c1">#print(&quot;IF loop duration: mean: {:.3f} s | std: {:.3f} s&quot;.format(np.mean(self.timing), np.std(self.timing)))</span>

    <span class="k">def</span> <span class="nf">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;[INFO] IF sub-process is now terminating.&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="if_time_domain_animation"><a class="viewcode-back" href="../../source/fmcw.html#fmcw.postprocessing.if_time_domain_animation">[docs]</a><span class="k">class</span> <span class="nc">if_time_domain_animation</span><span class="p">():</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tfd_angles</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">blit</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize an object that will contain the IF plot.</span>
<span class="sd">        :param tfd_angles:</span>
<span class="sd">        :param s: Settings dictionary</span>
<span class="sd">        :param grid: Display the grid on the plot screen.</span>
<span class="sd">        :param blit: Blit is used to speed up image display by caching what is not redrawn.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># 1. Save the figure in this object</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">tfd_angles</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="s2">&quot;IF time domain&quot;</span><span class="p">)</span>
        <span class="n">move_figure</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fig</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># Figure 1 is in the top left corner</span>

        <span class="c1"># 2. Set up the static parts of the figure</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Time [s]&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Voltage [V]&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lines</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
        <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;cblim_if&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="p">[]:</span>  <span class="c1"># Set the color bar limits if they have been defined. Otherwise, dynamic.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;cblim_if&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>

        <span class="c1"># 3. Display initial data (zeros) to activate the figure</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>  <span class="c1"># note that the first draw comes before setting data</span>
        <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;active_channels&#39;</span><span class="p">]:</span>  <span class="c1"># Channels are 1 based due to hardware considerations</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lines</span><span class="p">[</span><span class="n">channel</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">),)),</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;CH&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">channel</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># Grab first in list</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;best&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">block</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>  <span class="c1"># Display the figure</span>

        <span class="c1"># 4. If blitting, cache background</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">blit</span> <span class="o">=</span> <span class="n">blit</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">blit</span><span class="p">:</span>
            <span class="c1"># cache the background</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">axbackground</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">copy_from_bbox</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">bbox</span><span class="p">)</span>

<div class="viewcode-block" id="if_time_domain_animation.update_plot"><a class="viewcode-back" href="../../source/fmcw.html#fmcw.postprocessing.if_time_domain_animation.update_plot">[docs]</a>    <span class="k">def</span> <span class="nf">update_plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">if_data</span><span class="p">,</span> <span class="n">time_stamp</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Dynamic refresh of the IF plot.</span>
<span class="sd">        A lot of work has been put in reducing the time necessary to refresh a plot. There must be some possible</span>
<span class="sd">        improvements, especially by messing with the backend directly.</span>
<span class="sd">        TO DO: less data points could be plotted as an entire sweep is likely to contain more points than pixels</span>
<span class="sd">        available to it on the screen.</span>
<span class="sd">        :param if_data: processed IF data from a sweep</span>
<span class="sd">        :param time_stamp: Timestamp for the current sweep</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="n">if_data</span><span class="p">:</span>  <span class="c1"># Update y-data only, for all active channels</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lines</span><span class="p">[</span><span class="n">channel</span><span class="p">]</span><span class="o">.</span><span class="n">set_ydata</span><span class="p">(</span><span class="n">if_data</span><span class="p">[</span><span class="n">channel</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;IF time-domain at time T = </span><span class="si">{:.3f}</span><span class="s1"> s | FPGA time: </span><span class="si">{:.1f}</span><span class="s1"> s (lag: </span><span class="si">{:.1f}</span><span class="s1"> s)&#39;</span>
                          <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time_stamp</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">time_stamp</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">time_stamp</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">time_stamp</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>  <span class="c1"># Update title</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">blit</span><span class="p">:</span>  <span class="c1"># Given the performance boost, should be the default case</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">restore_region</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axbackground</span><span class="p">)</span>  <span class="c1"># restore background</span>
            <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="n">if_data</span><span class="p">:</span>  <span class="c1"># redraw just the points</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">draw_artist</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lines</span><span class="p">[</span><span class="n">channel</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">blit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">bbox</span><span class="p">)</span>  <span class="c1"># fill in the axes rectangle</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">flush_events</span><span class="p">()</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">flush_events</span><span class="p">()</span>  <span class="c1"># The order does not seem to matter with canvas.draw()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fig</span><span class="o">.</span><span class="n">number</span><span class="p">)</span></div>


<div class="viewcode-block" id="angle_display"><a class="viewcode-back" href="../../source/fmcw.html#fmcw.postprocessing.angle_display">[docs]</a><span class="k">class</span> <span class="nc">angle_display</span><span class="p">(</span><span class="n">mp</span><span class="o">.</span><span class="n">Process</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sub-process to display the angular information coming from both receivers.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tfd_angles</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">data_accessible</span><span class="p">,</span> <span class="n">new_sweep_angle</span><span class="p">,</span> <span class="n">sweep_to_display</span><span class="p">,</span> <span class="n">time_stamp</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Nothing too special here. Store a bunch of information.</span>
<span class="sd">        :param tfd_angles: x axis data</span>
<span class="sd">        :param s: Settings dictionary</span>
<span class="sd">        :param data_accessible: shared mp.Event that acts as a Lock when the sweep data is being updated.</span>
<span class="sd">        :param new_sweep_if: shared mp.Event that signals when a new sweep is ready to be plotted for its Angle.</span>
<span class="sd">        :param sweep_to_display: data to be displayed</span>
<span class="sd">        :param time_stamp: shared mp.Array that contains a few timestamp infos</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mp</span><span class="o">.</span><span class="n">Process</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>  <span class="c1"># Mandatory call to super</span>
        <span class="c1"># Create the window</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">s</span> <span class="o">=</span> <span class="n">s</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tfd_angles</span> <span class="o">=</span> <span class="n">tfd_angles</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">previous_sweep_counter</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;refresh_stride&#39;</span><span class="p">]</span> <span class="c1"># Virtual initial condition</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_accessible</span> <span class="o">=</span> <span class="n">data_accessible</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">new_sweep_angle</span> <span class="o">=</span> <span class="n">new_sweep_angle</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sweep_to_display</span> <span class="o">=</span> <span class="n">sweep_to_display</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time_stamp</span> <span class="o">=</span> <span class="n">time_stamp</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timing</span> <span class="o">=</span> <span class="p">[]</span>

<div class="viewcode-block" id="angle_display.run"><a class="viewcode-back" href="../../source/fmcw.html#fmcw.postprocessing.angle_display.run">[docs]</a>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Angle sub-process loop</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Create the figure object. Does not work when done in __init__ for some reason</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">window</span> <span class="o">=</span> <span class="n">angle_animation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tfd_angles</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;cross-range&#39;</span><span class="p">,</span> <span class="n">blit</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># Main loop. Exits when the parent process terminates the process</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="c1"># 1. Wait for the data flag to be set</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data_accessible</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">new_sweep_angle</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>

            <span class="c1"># 2. Retrieve the latest data and make a copy of it</span>
            <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sweep_to_display</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span>  <span class="c1"># Makes a copy of that shared memory</span>
            <span class="n">time_stamp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time_stamp</span><span class="p">)</span>  <span class="c1"># Same here, make a copy of the shared memory</span>

            <span class="c1"># 3. Reshape the sweep data as it had to be fit in a static, 1D, C-style array.</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;channel_count&#39;</span><span class="p">],</span>
                               <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;t_sweep&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;if_amplifier_bandwidth&#39;</span><span class="p">])))</span>
            <span class="n">data</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">arr</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;active_channels&#39;</span><span class="p">])}</span>  <span class="c1"># dict for compatibility</span>

            <span class="c1"># 4. Process the data to determine the angular components</span>
            <span class="n">fxdb</span> <span class="o">=</span> <span class="n">calculate_angle_plot</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tfd_angles</span><span class="p">)</span>

            <span class="c1"># 5. Sanity checks: did we skip some refreshes for being too slow?</span>
            <span class="n">sweeps_skipped</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">((</span><span class="n">time_stamp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">previous_sweep_counter</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;refresh_stride&#39;</span><span class="p">]))</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">sweeps_skipped</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="c1"># Some refreshes were skipped - not good!!</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;[WARNING] Refresh rate cannot be sustained for angle data | [</span><span class="si">{}</span><span class="s2">; </span><span class="si">{}</span><span class="s2">[ (total: </span><span class="si">{}</span><span class="s2">) were skipped&quot;</span>
                      <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">previous_sweep_counter</span><span class="p">,</span>
                              <span class="bp">self</span><span class="o">.</span><span class="n">previous_sweep_counter</span> <span class="o">+</span> <span class="n">sweeps_skipped</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;refresh_stride&#39;</span><span class="p">],</span>
                              <span class="n">sweeps_skipped</span><span class="p">))</span>

            <span class="c1"># 6. Update the figure</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">window</span><span class="o">.</span><span class="n">update_plot</span><span class="p">(</span><span class="n">fxdb</span><span class="p">,</span> <span class="n">time_stamp</span><span class="p">)</span>

            <span class="c1"># 7. Set the necessary counters and flags</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">previous_sweep_counter</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">time_stamp</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">new_sweep_angle</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">timing</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span> <span class="o">-</span> <span class="n">t0</span><span class="p">)</span></div>
            <span class="c1">#print(&quot;Angle loop duration: mean: {:.3f} s | std: {:.3f} s&quot;.format(np.mean(self.timing), np.std(self.timing)))</span>

    <span class="k">def</span> <span class="nf">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;[INFO] Angle sub-process is now terminating.&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="angle_animation"><a class="viewcode-back" href="../../source/fmcw.html#fmcw.postprocessing.angle_animation">[docs]</a><span class="k">class</span> <span class="nc">angle_animation</span><span class="p">():</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tfd_angles</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;angle&#39;</span><span class="p">,</span> <span class="n">blit</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize an object that will contain the Angle plot</span>
<span class="sd">        :param tfd_angles:</span>
<span class="sd">        :param s: Settings dictionary</span>
<span class="sd">        :param method: Various types of angular plots are available</span>
<span class="sd">        :param blit: Blit is used to speed up image display by caching what is not redrawn.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># 1. Save the figure in this object</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">tfd_angles</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="n">tfd_angles</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">angles_masked</span> <span class="o">=</span> <span class="n">angles</span><span class="p">[</span><span class="n">tfd_angles</span><span class="p">[</span><span class="mi">4</span><span class="p">]]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="s2">&quot;Angle&quot;</span><span class="p">)</span>
        <span class="n">move_figure</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fig</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># Figure 2 is in the middle</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">=</span> <span class="n">method</span>
        <span class="n">fxdb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">angles_masked</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">)))</span>  <span class="c1"># For figure initialization only</span>

        <span class="c1"># 2. Select the type of figure to display</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;polar&#39;</span><span class="p">:</span>  <span class="c1"># Polar plot, looks cool but takes a lot of space (displays all 360 degrees)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span> <span class="n">polar</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;???&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;???&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;cross-range&#39;</span><span class="p">:</span>  <span class="c1"># Best type, shows a cone of detection</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
            <span class="c1"># self.ax.set_xlim([0, max_range])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Range [m]&quot;</span><span class="p">)</span>
            <span class="n">ylim</span> <span class="o">=</span> <span class="mi">90</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angles_masked</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">180</span><span class="p">)</span>
            <span class="n">ylim</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="n">ylim</span><span class="p">,</span> <span class="n">ylim</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Cross-range [m]&quot;</span><span class="p">)</span>
            <span class="n">r</span><span class="p">,</span> <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">angles_masked</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">180</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="o">-</span><span class="n">r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;angle&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">quad</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">angles_masked</span><span class="p">,</span> <span class="n">fxdb</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">([</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;max_range&#39;</span><span class="p">]])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Range [m]&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">([</span><span class="n">angles_masked</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">angles_masked</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Angle [$^o$]&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;[ERROR] Incorrect method for the angle plots&#39;</span><span class="p">)</span>


        <span class="c1"># 3. Display initial data (zeros) to activate the figure</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>  <span class="c1"># Get ready to cache this</span>

        <span class="c1"># 4. If blitting, cache background</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">blit</span> <span class="o">=</span> <span class="n">blit</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">blit</span><span class="p">:</span>
            <span class="c1"># cache the background</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">axbackground</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">copy_from_bbox</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">bbox</span><span class="p">)</span>

        <span class="c1"># 5. Depending on type, display initial plot</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;polar&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">quad</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span><span class="n">angles_masked</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">180</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">fxdb</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;cross-range&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">quad</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">fxdb</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;angle&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">quad</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">angles_masked</span><span class="p">,</span> <span class="n">fxdb</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;[ERROR] Incorrect method for the angle plots&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">colorbar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">quad</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;cblim_angle&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="p">[]:</span>  <span class="c1"># Set the color bar limits if they have been defined. Otherwise, dynamic.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">quad</span><span class="o">.</span><span class="n">set_clim</span><span class="p">(</span><span class="o">*</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;cblim_angle&#39;</span><span class="p">])</span>

<div class="viewcode-block" id="angle_animation.update_plot"><a class="viewcode-back" href="../../source/fmcw.html#fmcw.postprocessing.angle_animation.update_plot">[docs]</a>    <span class="k">def</span> <span class="nf">update_plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fxdb</span><span class="p">,</span> <span class="n">time_stamp</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Dynamic refresh of the angular plot.</span>
<span class="sd">        A lot of work has been put in reducing the time necessary to refresh a plot. There must be some possible</span>
<span class="sd">        improvements, especially by messing with the backend directly.</span>
<span class="sd">        TO DO: less data points could be plotted as an entire sweep is likely to contain more points than pixels</span>

<span class="sd">        :param fxdb: Angular data to plot</span>
<span class="sd">        :param time_stamp: Timestamp for the current sweep</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;polar&#39;</span><span class="p">:</span>
            <span class="n">fxdb</span> <span class="o">=</span> <span class="n">fxdb</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
        <span class="c1"># https://stackoverflow.com/questions/18797175/animation-with-pcolormesh-routine-in-matplotlib-how-do-i-initialize-the-data</span>
        <span class="c1"># https://stackoverflow.com/questions/29009743/using-set-array-with-pyplot-pcolormesh-ruins-figure</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">quad</span><span class="o">.</span><span class="n">set_array</span><span class="p">(</span><span class="n">fxdb</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
        <span class="c1"># self.quad.set_clim(*cblim)  # Updates the colorbar</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Angle plot at time T = </span><span class="si">{:.3f}</span><span class="s1"> s | FPGA time: </span><span class="si">{:.1f}</span><span class="s1"> s (lag: </span><span class="si">{:.1f}</span><span class="s1"> s)&#39;</span>
                          <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time_stamp</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">time_stamp</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">time_stamp</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">time_stamp</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>


        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">blit</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">restore_region</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axbackground</span><span class="p">)</span>  <span class="c1"># restore background</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">draw_artist</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">quad</span><span class="p">)</span>  <span class="c1"># redraw just the points</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">blit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">bbox</span><span class="p">)</span>  <span class="c1"># fill in the axes rectangle</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">flush_events</span><span class="p">()</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">flush_events</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span></div>


    <span class="k">def</span> <span class="nf">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fig</span><span class="o">.</span><span class="n">number</span><span class="p">)</span></div>


<div class="viewcode-block" id="range_time_display"><a class="viewcode-back" href="../../source/fmcw.html#fmcw.postprocessing.range_time_display">[docs]</a><span class="k">class</span> <span class="nc">range_time_display</span><span class="p">(</span><span class="n">mp</span><span class="o">.</span><span class="n">Process</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tfd_angles</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">data_accessible</span><span class="p">,</span> <span class="n">new_sweep_range_time</span><span class="p">,</span> <span class="n">sweep_to_display</span><span class="p">,</span> <span class="n">time_stamp</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Nothing too special here. Store a bunch of information.</span>
<span class="sd">        :param tfd_angles: x axis data</span>
<span class="sd">        :param s: Settings dictionary</span>
<span class="sd">        :param data_accessible: shared mp.Event that acts as a Lock when the sweep data is being updated.</span>
<span class="sd">        :param new_sweep_if: shared mp.Event that signals when a new sweep is ready to be plotted for its range time.</span>
<span class="sd">        :param sweep_to_display: data to be displayed</span>
<span class="sd">        :param time_stamp: shared mp.Array that contains a few timestamp infos</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mp</span><span class="o">.</span><span class="n">Process</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>  <span class="c1"># Mandatory call to super</span>

        <span class="c1"># Create the window</span>
        <span class="n">max_range_index</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;sweep_length&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;max_range&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;range_adc&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_range_index</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">max_range_index</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;sweep_length&#39;</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">s</span> <span class="o">=</span> <span class="n">s</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">previous_sweep_counter</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;refresh_stride&#39;</span><span class="p">]</span> <span class="c1"># Virtual initial condition</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_accessible</span> <span class="o">=</span> <span class="n">data_accessible</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">new_sweep_range_time</span> <span class="o">=</span> <span class="n">new_sweep_range_time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sweep_to_display</span> <span class="o">=</span> <span class="n">sweep_to_display</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time_stamp</span> <span class="o">=</span> <span class="n">time_stamp</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timing</span> <span class="o">=</span> <span class="p">[]</span>

<div class="viewcode-block" id="range_time_display.run"><a class="viewcode-back" href="../../source/fmcw.html#fmcw.postprocessing.range_time_display.run">[docs]</a>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Range time sub-process loop</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Create the figure object. Does not work when done in __init__ for some reason</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">window</span> <span class="o">=</span> <span class="n">range_time_animation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_range_index</span><span class="p">,</span> <span class="n">blit</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># Main loop. Exits when the parent process terminates the process</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="c1"># 1. Wait for the data flag to be set</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data_accessible</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">new_sweep_range_time</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>

            <span class="c1"># 2. Retrieve the latest data and make a copy of it</span>
            <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sweep_to_display</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span>  <span class="c1"># Makes a copy of that shared memory</span>
            <span class="n">time_stamp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time_stamp</span><span class="p">)</span>  <span class="c1"># Same here, make a copy of the shared memory</span>

            <span class="c1"># 3. Reshape the sweep data as it had to be fit in a static, 1D, C-style array.</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;channel_count&#39;</span><span class="p">],</span>
                               <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;t_sweep&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;if_amplifier_bandwidth&#39;</span><span class="p">])))</span>
            <span class="n">data</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">arr</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;active_channels&#39;</span><span class="p">])}</span>

            <span class="c1"># 4. Process the data to determine the angular components</span>
            <span class="n">im</span><span class="p">,</span> <span class="n">nb_sweeps</span><span class="p">,</span> <span class="n">max_range_index</span> <span class="o">=</span> <span class="n">calculate_range_time</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">,</span> <span class="n">single_sweep</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

            <span class="c1"># 5. Sanity checks: did we skip some refreshes for being too slow?</span>
            <span class="n">sweeps_skipped</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">((</span><span class="n">time_stamp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">previous_sweep_counter</span><span class="p">)</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;refresh_stride&#39;</span><span class="p">]))</span><span class="o">-</span><span class="mi">1</span>
            <span class="k">assert</span> <span class="n">sweeps_skipped</span> <span class="o">&gt;=</span> <span class="mi">0</span>
            <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">sweeps_skipped</span><span class="p">)</span> <span class="o">==</span> <span class="nb">int</span>
            <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">sweeps_skipped</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="c1"># Some refreshes were skipped - not good!!</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;[WARNING] Refresh rate cannot be sustained for RT data | [</span><span class="si">{}</span><span class="s2">; </span><span class="si">{}</span><span class="s2">[ (total: </span><span class="si">{}</span><span class="s2">) were skipped&quot;</span>
                      <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">previous_sweep_counter</span><span class="p">,</span>
                              <span class="bp">self</span><span class="o">.</span><span class="n">previous_sweep_counter</span> <span class="o">+</span> <span class="n">sweeps_skipped</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;refresh_stride&#39;</span><span class="p">],</span>
                              <span class="n">sweeps_skipped</span><span class="p">))</span>

            <span class="c1"># 6. Update the figure</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">window</span><span class="o">.</span><span class="n">update_plot</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">time_stamp</span><span class="p">,</span> <span class="n">sweeps_skipped</span><span class="p">)</span>

            <span class="c1"># 7. Set the necessary counters and flags</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">previous_sweep_counter</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">time_stamp</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">new_sweep_range_time</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">timing</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span> <span class="o">-</span> <span class="n">t0</span><span class="p">)</span></div>
            <span class="c1">#print(&quot;RT loop duration: mean: {:.3f} s | std: {:.3f} s&quot;.format(np.mean(self.timing), np.std(self.timing)))</span>

    <span class="k">def</span> <span class="nf">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;[INFO] Range time is now terminating&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="range_time_animation"><a class="viewcode-back" href="../../source/fmcw.html#fmcw.postprocessing.range_time_animation">[docs]</a><span class="k">class</span> <span class="nc">range_time_animation</span><span class="p">():</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">max_range_index</span><span class="p">,</span> <span class="n">blit</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize an object that will contain the Range Time plot</span>
<span class="sd">        :param tfd_angles:</span>
<span class="sd">        :param s: Settings dictionary</span>
<span class="sd">        :param max_range_index: Maximum index used to display the requested range (or max dictated but Fourier)</span>
<span class="sd">        :param blit: Blit is used to speed up image display by caching what is not redrawn.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># 1. Save the figure in this object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="s2">&quot;Range-time&quot;</span><span class="p">)</span>
        <span class="n">move_figure</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fig</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">([</span><span class="o">-</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;real_time_recall&#39;</span><span class="p">],</span> <span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Time [s]&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Range [m]&quot;</span><span class="p">)</span>

        <span class="c1"># 2. Set up the static parts of the figure</span>
        <span class="n">nb_sweeps</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;real_time_recall&#39;</span><span class="p">]</span><span class="o">/</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;refresh_period&#39;</span><span class="p">])</span><span class="o">+</span><span class="mi">1</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;real_time_recall&#39;</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nb_sweeps</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;range_adc&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">max_range_index</span><span class="o">/</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;sweep_length&#39;</span><span class="p">],</span> <span class="n">max_range_index</span><span class="o">-</span><span class="mi">2</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">max_range_index</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="n">nb_sweeps</span><span class="p">))</span>  <span class="c1"># Store the value currently displayed for speed</span>

        <span class="c1"># 3. Cache the dynamic parts of the figure</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>  <span class="c1"># note that the first draw comes before setting data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">quad</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_array</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">colorbar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">quad</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="p">)</span>


        <span class="c1"># 4. If blitting, cache background</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">blit</span> <span class="o">=</span> <span class="n">blit</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">blit</span><span class="p">:</span>
            <span class="c1"># cache the background</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">axbackground</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">copy_from_bbox</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">bbox</span><span class="p">)</span>

        <span class="c1">#self.quad.set_array(self.current_array[:-1, :-1].ravel())</span>
        <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;cblim_range_time&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="p">[]:</span>  <span class="c1"># Set the color bar limits if they have been defined. Otherwise, dynamic.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">quad</span><span class="o">.</span><span class="n">set_clim</span><span class="p">(</span><span class="o">*</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;cblim_range_time&#39;</span><span class="p">])</span>

<div class="viewcode-block" id="range_time_animation.update_plot"><a class="viewcode-back" href="../../source/fmcw.html#fmcw.postprocessing.range_time_animation.update_plot">[docs]</a>    <span class="k">def</span> <span class="nf">update_plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">time_stamp</span><span class="p">,</span> <span class="n">sweeps_skipped</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Dynamic refresh of the Range time plot</span>
<span class="sd">        A lot of work has been put in reducing the time necessary to refresh a plot. There must be some possible</span>
<span class="sd">        improvements, especially by messing with the backend directly.</span>
<span class="sd">        TO DO: less data points could be plotted as an entire sweep is likely to contain more points than pixels</span>
<span class="sd">        available to it on the screen.</span>
<span class="sd">        :param im: range time data</span>
<span class="sd">        :param time_stamp: Timestamp for the current sweep</span>
<span class="sd">        :param sweeps_skipped: Important here to duplicate the current sweep as many times as sweeps we skipped</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Roll current data along its columns as many times as sweeps we have skipped + 1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_array</span><span class="p">,</span> <span class="o">-</span><span class="n">sweeps_skipped</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Replaced the rolled data with the new sweep data, duplicated as required</span>
        <span class="n">im</span> <span class="o">=</span> <span class="n">im</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># Make the data 2D for broadcasting</span>
        <span class="n">im</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sweeps_skipped</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_array</span><span class="p">[:,</span> <span class="o">-</span><span class="n">sweeps_skipped</span><span class="o">-</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span>  <span class="n">im</span> <span class="c1"># Substitute the new array &amp; pad</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">quad</span><span class="o">.</span><span class="n">set_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_array</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>  <span class="c1"># Flatten the data</span>
        <span class="c1"># self.quad.set_clim(*cblim)  # Updates the colorbar</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Range time plot at time T = </span><span class="si">{:.3f}</span><span class="s1"> s | FPGA time: </span><span class="si">{:.1f}</span><span class="s1"> s (lag: </span><span class="si">{:.1f}</span><span class="s1"> s)&#39;</span>
                          <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time_stamp</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">time_stamp</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">time_stamp</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">time_stamp</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">blit</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">restore_region</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axbackground</span><span class="p">)</span>  <span class="c1"># restore background</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">draw_artist</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">quad</span><span class="p">)</span>  <span class="c1"># redraw just the points</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">blit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">bbox</span><span class="p">)</span>  <span class="c1"># fill in the axes rectangle</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">flush_events</span><span class="p">()</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">flush_events</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fig</span><span class="o">.</span><span class="n">number</span><span class="p">)</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, Alexandre Bondoux

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>